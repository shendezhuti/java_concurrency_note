# 并发编程的其他基础知识

- [什么是多线程并发编程](#1)
- [为什么要进行多线程并发编程](#2)
- [Java中的线程安全问题](#3)
- [Java中共享变量的内存可见性问题](#4)
- [Java中的synchronized关键字](#5)
- [Java中的volatile关键字](#6)
- [Java中的原子性操作](#7)
- [Java中的CAS操作](#8)
- [Unsafe类](#9)
- [Java指令重排序](#10)
- [伪共享](#11)
- [锁的概述](#12)

<h2 id='1'>什么是多线程并发编程</h2>
​		并发和并行是不一样的概念，并发是指 **同一时间段** 内有个多个任务在同时执行，并且都没有执行结束，而并行是说在单位时间内 **多个任务同时** 在执行。

​		在多线程编程实践中，线程的个数往往多于CPU的个数，所以一般都称为多线程并发编程而不是多线程并行编程。

<h2 id='2'>
  为什么要进行多线程并发编程
</h2>

​		多核CPU时代的到来打破了单核CPU对多线程功效的限制。多个CPU意味着每个线程都可以使用自己的CPU运行，这减少了线程上下文切换的开销，但是随着对应用系统性能和吞吐量要求的提高，出现了处理海量数据和请求的要求，这些都对高并发编程有着迫切的需求。

<h2 id='3'>Java中的线程安全问题</h2>
​		共享资源：被多个线程持有（多个线程都可以访问该资源）

​		线程中的安全问题是指当多个线程同时去读写一个共享资源并且没有任何同步措施的时候，导致出现脏数据或者其他不可预见的结果的问题。

​		如何解决共享变量的线程安全问题？需要在线程访问共享变量时进行适当的同步，

<h2 id='4'>Java中共享变量的内存可见性问题</h2>
​		在双核的CPU系统架构中，每个核有自己的控制器和运算器，其中控制器包含一组寄存器和操作控制器，运算器执行算术逻辑运算。每个核都有自己的一级缓存，在有些架构里面还有一个所有CPU都共享的二级缓存。那么Java内存模型里面的工作内存，就对应这里的L1或者L2缓存或者CPU的寄存器。

​		当一个线程操作共享变量时， 它首先从主内存复制共享变量到自己的工作内存， 然后 对工作 内存里 的变量进行处理， 处理完后将变量值更新到主 内存。 

​		那么假如线程 A 和线程 B 同时处理一个共享变量 ，会出现什么情况? 假设线程A和线程B使用不同CPU执行，并且当前两级Cache都为空， 那么这时候由于 Cache 的存在，将会导致内存不可见 问题 ， 具体看下面的分析。 

- 线程A首先获取共享变量X的值，由于两级Cache都没有命中，所以加载主内存中X的值，假如为 0。然后把 X=O 的值缓存到两级缓存 ， 线程A修改 X 的值为1, 然后将其写入两级 Cache， 并且刷新到主内存 。 线程A操作完毕后，线程A所在的CPU的两级Cache内和主内存里面的 X 的值都是1。 

- 线程 B 获取 X 的值，首先一级缓存没有命中，然后看二级缓存，二级缓存命中了，所以返回X=1; 到这里一切都是正常的， 因为这时候主内存中也是X=1。然后线程B修改X的值为2， 并将其存放到线程2所在的一级 Cache 和共享二级 Cache 中， 最后更新主内存中X的值为2: 到这里一切都是好的。 

- 线程A这次又需要修改X的值， 获取时一级缓存命中， 并且X=1，到这里问题就出现了，明明线程B已经把 X 的值修改为了2，为何线程 A 获取的还是1呢? 这 就是共享变量的内存不可见问题 ， 也就是线程B 写入的值对线程A不可见。 

利用Java中的volatile关键字可以解决这个问题

<h2 id='5'>Java中的synchronized关键字
</h2>

​		synchronized块是Java提供的一种原子性内置锁，Java中的每个对象都可以把它当做一个同步锁来使用，Java这些内置的使用者看不到的锁被称为内部锁，也叫监视器锁。线程的执行代码在进入synchronized代码块前会自动获取内部锁，这时候其他线程访问该同步代码块时会被阻塞挂起。拿到内部锁的线程会在正常退出同步代码块或者抛出异常后或者在同步块内调用了该内置锁资源的wait系列方法时释放该内置锁。内置锁是排它锁，也就是当一个线程获取这个锁后，其他线程必须等待该线程释放锁后才能获取该锁。

​		由于Java中的线程是与操作系统的原生线程一一对应的，所以当阻塞一个线程时，需要从用户态切换到内核态执行阻塞操作，这是耗时的操作，而synchronized的使用就会导致上下文切换

​		前面介绍了共享变量内存可见性问题主要是由于线程的工作内存导致的，下面我们来讲解synchronized的一个内存语义，这个内存语义就可以解决共享变量内存可见性问题。进入synchronized块的内存语义是在synchronized块内使用到的变量从线程的工作内存中清除，这样在synchronized块内使用到该变量时就不会从线程的工作内存中获取，而是直接从主内存中获取。退出synchronized块的内存语义是把在synchronized块内对共享变量的修改刷新到主内存。

​		其实这也是加锁和释放锁的语义，当获取锁后会清空锁块内本地内存中将会被用到的共享变量，在使用这些共享变量时从主内存进行加载，在释放锁将本地内存中修改的共享变量刷新到主内存。

​		除了可以解决共享变量内存可见性问题外，synchronized经常被用来实现原子性操作。另外请注意，synchronized关键字会引起上下文切换并带来线程调度开销。

<h2 id='6'>Java中的volatile关键字</h2>
​		上面提到可以利用锁的方式解决共享变量内存可见性的问题，但是使用锁很笨重，因为它会带来线程上下文切换开销。对于解决内存可见性问题，Java还提供了一种弱形式的同步，也就是使用volatile关键字。该关键字可以确保对一个变量的更新对其他线程马上可见。当一个变量为声明为volatile的时候，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是直接把值刷新回主内存。当其他线程读取该共享变量的时候，就会从主内存重新获取最新值，而不是使用当前线程的工作内存中的值。volatile的内存语义和synchronized有相似之处，具体来书就是，当线程写出了volatile变量值时就等价于线程退出synchronized同步块（把写入工作内存的变量值同步到主内存），读取volatile变量时就相当于进入同步块（把写入工作内存的变量值同步到主内存），读取volatile变量值时就相当于进入同步块（先清空本地内存变量值，再从主内存获取最新值)

​		使用synchronized和使用volatile有时候是等价的，但是并非所有情况都是等价的，volatile虽然提供了可见性保证，但是并不保证操作的原子性。

​		那么一般在什么时候才使用volatile关键字呢？

- 写入变量值不依赖变量的当前值。因为如果依赖当前值，将是获取-计算-写入三步操作，这三步操作不是原子性的，而volatile不保证原子性。
- 读取变量值时没有加锁。因为加锁本身已经保证了内存可见性，这时候不需要把变量声明为volatile

<h2 id='7'>
  Java中的原子性操作
</h2>

​	所谓原子性操作，是指执行一系列操作时，这些操作要么全部执行，要么全部不执行，不存在只执行一部分的情况。在设计计数器时一般都是读取当前值，然后+1，再更新。这个过程是读-改-写的过程，如果不能保证保证这个过程是原子性的，那么就会出现线程安全性问题。

​	保证多个操作的原子性最简单的办法就是使用synchronized关键字进行同步

```java
public class ThreadSafeCount{
  private long value;
  public synchronized long getCount(){
    return value;
  }
  public synchronized void inc(){
    ++value;
  }
}
```

​	使用synchronized 关键字的确可以实现线程安全性，即内存可见性和原子性，但是synchronized是独占锁，没有获取内部锁的线程会被阻塞掉，而这里的getCount方法只是读操作，多个线程同时调用不会存在线程安全问题。但是加了关键字synchronized后，同一时间就只能有一个线程可以调用，这显然大大降低了并发性。你也许回文，既然只是读操作，那么为何不去掉getCount方法上面的synchronized关键字呢？其实是不能去掉的，别忘了这里要靠synchronized来实现value的内存可见性。那么有更好的实现呢？答案是

<h2 id='8'>Java中的CAS操作</h2>
​	前面讲的锁和volatile关键字都有一定自身的缺点。CAS即compae and swap，其是提供的非阻塞原子性操作，它通过硬件保证了比较-更新操作的原子性。JDK里面的Unsafe类提供了一系列的compareAndSwap*方法，下面以compareAndSwapLong方法方法为例进行简单的介绍

- boolean compareAndSwapLong(Object obj,long valueOffset,long expect, long update)方
  法:其中compareAndSwap的意思是比较并交换。CAS有四个操作数， 分别为:对
  象内存位置 、 对象中 的变量的偏移量 、 变量预期值和新的值 。 其操作含义是 ， 如果
  对象 obj 中内存偏移量为 valueOffset的变量值为 expect，则使用新的值 update替换
  旧的值 expect。 这是处理器提供的一个原子性指令。

​      关于CAS操作有个经典的ABA问题， 具体如下: 假如线程1使用CAS修改初始值为A的变量X， 那么线程1会首先去获取当前变量X的值(为A)， 然后使用CAS操作尝试修改 X 的值为 B，如果使用CAS操作成功了，那么程序运行一定是正确的吗?其实未必，这是因为有可能在线程1获取变量X的值 A 后，在执行 CAS 前，线程2使用 CAS 修改了变量X的值为B，然后又使用CAS修改了变量X的值为A。 所以虽然线程1执行CAS 时X的值是A， 但是这个A已经不是线程1获取时的A了。 这就是ABA问题。 ABA 问题 的产生是因为变量的状态值产生了环形转换，就是变量的值可以从A到B, 然后再从B到A。如果变量的值只能朝着一个方向转换 ，比如A到B,B到C， 不构成环形，就不会存在问题。 JDK中的AtomicStampedReference 类给每个变量的状态值都配备了一个时间戳， 从而避免了ABA问题的产生。 

<h2 id='9'>Unsafe类</h2>
​	JDK的rt.jar包的Unsasfe类提供了硬件级别的原子性操作

<h2 id='10'>Java指令重排序</h2>
​	Java内存模型允许编译器和处理器对指令重排序以提高运行的性能，并且只会对不存在数据依赖性的指令重排序。在单线程下重排序可以保证最终执行的结果与程序顺序执行的结果结果一致，但是在多线程下就会存在问题。

​	重排序在多线程下会导致非预期的程序执行结果，而使用volatile修饰的ready就可以避免重排序和内存可见性问题。

​	写volatile变量时，可以确保volatile写之前的操作不会被编译器重排序到volatile写之后。读volatile变量时，可以确保volatile读之后的操作不会被编译器重排序到volatile读之前。

<h2 id='11'>伪共享</h2>
​	由于CPU内部有cache，cache是按行存储的，因此如果把多个变量存在一个cache行中。当多个线程同时修改一个缓存行里面的多个变量时，由于同时只能有一个线程操作缓存行，所以相比将每个变量放到一个缓存行，性能会有所下降，这就是伪共享。（注意单线程下访问一个缓存行里面的多个变量反而会对程序运行起到加速的作用）

​	在JDK8之前一般都是通过字节填充的方式来避免该问题，也就是创建一个变量时使用填充字段填充该变量所在的缓存行，这样就避免了将多个变量存在同一个缓存行中。

​	JDK8提供了一个sun.misc.Conteded注解，用来解决伪共享问题。

<h2 id='12'>锁的概述</h2>

### 悲观锁与乐观锁

​	悲观锁：对数据被外界修改持保守态度，认为数据很容易就会被其他线程修改，所以在数据被处理前先对数据进行加锁，并在整个数据处理过程中，使数据处于锁定状态。悲观锁的实现往往依靠数据库提供的锁机制，即在数据库中，在对数据记录操作前给记录加排它锁。如果获取锁失败，则说明数据正在被其他线程修改，当前线程则等待或者抛出异常。如果获取锁成功，则对记录进行操作，然后提交事务后释放排它锁。

​	乐观锁：乐观是相对悲观锁来说的，它认为数据在一般情况下不会造成冲突，所以在访问记录前不会加排它锁，而是在进行数据提交更新时，而是在进行数据提交更新时，才会正式对数据冲突与否进行检测。具体来说，根据update返回的行数让用户决定如何去做。乐观锁并不会使用数据库提供的锁机制，一般在表中添加version字段或者使用业务状态来实现。乐观锁直到提交才锁定，所以不会产生死锁。

### 公平锁与非公平锁

​	公平锁：公平锁表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的，也就是最早请求锁的线程将最早获取到锁。而非公平锁则是在运行时闯入，也就是先来不一定先得。

​	EeentrantLock提供了公平锁和非公平锁的实现。

- 公平锁：ReentrantLock pairLock=new ReentrantLock(true)

- 非公平锁: ReentrantLock pairLock=new ReentrantLock(false) 如果构造函数不传参数 默认非公平锁

  例如，假设线程A已经持有了锁，这时候线程B请求该锁其将会被挂起。当线程A释放锁后，加入当前有线程C也需要获取该锁，如果采用非公平锁的方式，根据线程调用策略，线程B和线程C两者之一可能获取锁，这时候不需要任何其他干涉，而如果使用公平锁则需要把C挂起，让B获取当前锁。

  在没有公平性需求的前提下要尽量使用非公平锁，**因为公平锁会带来性能的开销**。

### 独占锁与共享锁

​		根据锁只能被单个线程持有还是能被多个线程共同持有，锁可以分为独占锁和共享锁。

​		独占锁保证任何时候只有一个线程能得到锁，ReentranLock就是以独占方式实现的。共享锁则可以同时由多个线程持有，例如ReadWriteLock读写锁，它允许一个资源可以被多线程同时进行读操作。

​		独占锁是一种悲观锁，由于每次访问资源都先加上互斥锁，这限制了并发性，因为读操作并不会影响数据的一致性，而独占锁只允许在同一时间同一线程读取数据，其他线程必须等待当前线程释放锁才能进行读取。

​		共享锁则是一种乐观锁，它放宽了加锁的条件，允许多个线程同时进行读操作。

### 可重入锁

​		当一个线程要获取一个被其他线程持有的独占锁时，该线程会被阻塞，那么当一个线程再次获取它自己已经获取的锁是否会被阻塞呢？如果不被阻塞，那么我们说该锁是可以重入的，也就是只要该线程获取了该锁，那么可以无限次数（之后会知道严格来说有次数）地进入被该锁锁住的代码。

​		synchronized内部锁是可重入锁。可重入锁的原理是在锁内部维护一个线程标识，用来标识该锁目前被哪一个线程占用，然后关联一个计数器。一开始计数器值为0，说明该锁没有被任何线程占用。当一个线程获取了该锁时，计数器的值会变成1，这时其他线程再来获取该锁时就会发现锁的所有者不是自己而被阻塞挂起。

​		但是当获取了该锁的线程再次获取锁是发现锁的拥有者是自己，就会把计数器的值+1，当释放锁后计数器的值-1。当计数器的值为0时，锁里面的线程标识被重置为null，这时候被阻塞的线程会被唤醒来竞争获取该锁。

### 自旋锁

​		由于Java中的线程是与操作系统中的线程一一对应的，所以当一个线程在获取（比如独占锁）失败后，会被切换到内核状态而被挂起。当该线程获取到锁时又需要将其切换到内核状态而唤醒该线程。而从用户状态切换到内核状态的开销是比较大的，在一定程度上乎影响并发性能。自旋锁则是，当前线程在获取锁的时候，如果发现锁已经被其他线程占有，它不马上阻塞自己，在不放弃CPU使用权的情况，多次尝试获取（默认次数是10，可以使用 -XX:PreBlockSpinsh 参数设置该值），很有可能在后面的几次尝试中其他线程已经释放了该锁。如果尝试指定的次数后仍然没有获取到该锁则当前的线程才会被阻塞挂起。由此看来自旋锁是使用CPU时间换取线程阻塞与调用的开销，但是很有可能这些CPU时间也白白浪费了。

### 总结

本章主要介绍了并发编程 的基础知识，为后面在高级篇讲解并发包源码打下了基础， 并结合图示形象地讲述了为什么要使用多线程编程，多线程编程存在的线程安全问题，以及什么是内存可见性问题 。然后讲解了 synchronized 和 volatile 关键字，并且强调前者既 保证内存的可见性又保证原子性，而后者则主要保证内存可见性，但是二者的内存语义很相似 。 最后讲解了什么是 CAS 和线程问同步以及各种锁的概念，这些都为后面讲解JUC包源码奠定了基础。 





