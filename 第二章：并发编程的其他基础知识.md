# 并发编程的其他基础知识

- [什么是多线程并发编程](#1)
- [为什么要进行多线程并发编程](#2)
- [Java中的线程安全问题](#3)
- [Java中共享变量的内存可见性问题](#4)
- [Java中的synchronized关键字](#5)
- [Java中的volatile关键字](#6)
- [](#7)
- [](#8)
- [](#9)
- [](#10)
- [](#11)
- [](#12)

<h2 id='1'>什么是多线程并发编程</h2>
并发和并行是不一样的概念，并发是指**同一时间段**内有个多个任务在同时执行，并且都没有执行结束，而并行是说在单位时间内**多个任务同时**在执行。

在多线程编程实践中，线程的个数往往多于CPU的个数，所以一般都称为多线程并发编程而不是多线程并行编程。

<h2 id='2'>
  为什么要进行多线程并发编程
</h2>

多核CPU时代的到来打破了单核CPU对多线程功效的限制。多个CPU意味着每个线程都可以使用自己的CPU运行，这减少了线程上下文切换的开销，但是随着对应用系统性能和吞吐量要求的提高，出现了处理海量数据和请求的要求，这些都对高并发编程有着迫切的需求。

<h2 id='3'>Java中的线程安全问题</h2>
共享资源：被多个线程持有（多个线程都可以访问该资源）

线程中的安全问题是指当多个线程同时去读写一个共享资源并且没有任何同步措施的时候，导致出现脏数据或者其他不可预见的结果的问题。

如何解决共享变量的线程安全问题？需要在线程访问共享变量时进行适当的同步，

<h2 id='4'>Java中共享变量的内存可见性问题</h2>

在双核的CPU系统架构中，每个核有自己的控制器和运算器，其中控制器包含一组寄存器和操作控制器，运算器执行算术逻辑运算。每个核都有自己的一级缓存，在有些架构里面还有一个所有CPU都共享的二级缓存。那么Java内存模型里面的工作内存，就对应这里的L1或者L2缓存或者CPU的寄存器。

当一个线程操作共享变量时， 它首先从主内存复制共享变量到自己的工作内存， 然后 对工作 内存里 的变量进行处理， 处理完后将变量值更新到主 内存。 

那么假如线程 A 和线程 B 同时处理一个共享变量 ，会出现什么情况? 假设线程A和线程B使用不同CPU执行，并且当前两级Cache都为空， 那么这时候由于 Cache 的存在，将会导致内存不可见 问题 ， 具体看下面的分析。 

- 线程A首先获取共享变量X的值，由于两级Cache都没有命中，所以加载主内存中X的值，假如为 0。然后把 X=O 的值缓存到两级缓存 ， 线程A修改 X 的值为1, 然后将其写入两级 Cache， 并且刷新到主内存 。 线程A操作完毕后，线程A所在的CPU的两级Cache内和主内存里面的 X 的值都是1。 

- 线程 B 获取 X 的值，首先一级缓存没有命中，然后看二级缓存，二级缓存命中了 ， 所以返回X=1; 到这里一切都是正常的， 因为这时候主内存中也是X=1。然后线程B修改 X 的值为 2， 并将其存放到线程2所在的一级 Cache 和共享二级 Cache 中， 最后更新主内存中X的值为2: 到这里一切都是好的。 

- 线程A这次又需要修改X的值， 获取时一级缓存命中， 并且X=1，到这里问题就 出现了，明明线程B已经把 X 的值修改为了 2，为何线程 A 获取的还是1呢? 这 就是共享变量的内存不可见问题 ， 也就是线程B 写入的值对线程A不可见。 

利用Java中的volatile关键字可以解决这个问题

<h2 id='5'>Java中的synchronized关键字
</h2>

synchronized块是Java提供的一种原子性内置锁，Java中的每个对象都可以把它当做一个同步锁来使用，Java这些内置的使用者看不到的锁被称为内部锁，也叫监视器锁。线程的执行代码在进入synchronized代码块前会自动获取内部锁，这时候其他线程访问该同步代码块时会被阻塞挂起。拿到内部锁的线程会在正常退出同步代码块或者抛出异常后或者在同步块内调用了该内置锁资源的wait系列方法时释放该内置锁。内置锁是排它锁，也就是当一个线程获取这个锁后，其他线程必须等待该线程释放锁后才能获取该锁。

由于Java中的线程是与操作系统的原生线程一一对应的，所以当阻塞一个线程时，需要从用户态切换到内核态执行阻塞操作，这是耗时的操作，而synchronized的使用就会导致上下文切换

前面介绍了共享变量内存可见性问题主要是由于线程的工作内存导致的，下面我们来讲解synchronized的一个内存语义，这个内存语义就可以解决共享变量内存可见性问题。进入synchronized块的内存语义是在synchronized块内使用到的变量从线程的工作内存中清除，这样在synchronized块内使用到该变量时就不会从线程的工作内存中获取，而是直接从主内存中获取。退出synchronized块的内存语义是把在synchronized块内对共享变量的修改刷新到主内存。

其实这也是加锁和释放锁的语义，当获取锁后会清空锁块内本地内存中将会被用到的共享变量，在使用这些共享变量时从主内存进行加载，在释放锁将本地内存中修改的共享变量刷新到主内存。

除了可以解决共享变量内存可见性问题外，synchronized经常被用来实现原子性操作。另外请注意，synchronized关键字会引起上下文切换并带来线程调度开销。

<h2 id='6'>Java中的volatile关键字</h2>

上面提到可以利用锁的方式解决共享变量内存可见性的问题，但是使用锁很笨重，因为它会带来线程上下文切换开销。对于解决内存可见性问题，Java还提供了一种弱形式的同步，也就是使用volatile关键字。该关键字可以确保对一个变量的更新对其他线程马上可见。当一个变量为声明为volatile的时候，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是直接把值刷新回主内存。当其他线程读取该共享变量的时候，就会从主内存重新获取最新值，而不是使用当前线程的工作内存中的值。volatile的内存语义和synchronized有相似之处，具体来书就是，当线程写出了volatile变量值时就等价于线程退出synchronized同步块（把写入工作内存的变量值同步到主内存），读取volatile变量时就相当于进入同步块（把写入工作内存的变量值同步到主内存），读取volatile变量值时就相当于进入同步块（先清空本地内存变量值，再从主内存获取最新值)

