# 第一章：并发编程线程基础

## 目录

- [线程](#1)
- [wait()](#2)
- [notify()和notifyAll()](#3)
- [等待线程执行终止的join方法](#4)
- [](#5)
- [](#6)



<h2 id="1">线程  </h2>
在讨论什么是线程前有必要先说下什么是进程，因为线程是进程中的一个实体，线程本身是不会独立存在的 。 进程是代码在数据集合上的一次运行活动 ， 是系统进行资源分配 和调度的基本单位， 线程则是进程的一个执行路径， 一个进程中至少有一个线程，进程中的多个线程共享进程的资源。 

操作系统在分配资源时是把资源分配给进程的， 但是CPU资源比较特殊， 它是被分配到线程的 ， 因为真正要占用 CPU 运行的是线程 ，所以也说线程是 CPU 分配的基本单位。 

在Java中，当我们启动main函数时其实就启动了一个JVM的进程， 而main函数所在的线程就是这个进程中的一个线程，也称主线程 。 

<h2 id="1">wait()</h2>
当一个线程调用一个共享变量的wait()方法时， 该调用线程会被阻塞挂起， 直到发生下面几件事情之一才返回: (1)其他线程调用了该共享对象的 notify()或者notifyAll()方法; (2)其他线程调用了该线程的 interrupt()方法， 该线程抛出 InterruptedException异常返回。 

另外需要注意的是，如果调用 wait()方法的线程没有事先获取该对象的监视器锁，则调用 wait()方法时调用线程会抛出 IllegalMonitorStateException异常。 

那么 一个线程如何才能 获取一个共享变量的监视器锁呢 ? 

- 执行synchronized同步代码块时，使用该共享变量作为参数。

  ```java
  synchronized(共享变量){
  	//doSomething
  }
  ```

- 调用该共享变量的方法，并且该方法使用了synchronized修饰

- ```java
  synchronized void add(int a,int b){
  	//doSomething
  }
  ```

  > 注意：一个线程可以挂起编程运行状态（也就是被唤醒）。即便该线程没有被其他线程调用notify()/notifyAll()方法进行通知，或者被中断，或者等待超时，这是**虚假唤醒**

  书上提到，虚假唤醒在实践中比较少发生，但是我们也要防患于未然。做法就是不停地去测试该线程被唤醒的条件是否满足，不满足则继续等待。下面的代码是经典的调用共享变量wait()方法的实例，首先通过同步块获取obj上面的监视器锁，然后在while循环内调用obj的wait()方法。

  ```java
  synchronized (obj){
  	while(条件不满足){
  		obj.wait();
  	}
  }
  ```

下面从一个简单的生产者和消费者例子加深理解。如下面代码所示，其中 queue为共享
变量，生产者线程在调用 queue 的 wait() 方法前，使用 synchronized 关键字拿到了该共享变量
queue 的监视器锁，所以调用 waitO 方法才不会抛出 lliega!MonitorStateException异常 。如果当前
队列没有空闲容量则会调用 queued 的 wait() 方法挂起当前线程，这里使用循环就是为了
避 免上面说的虚假唤醒问题。假如当前线程被虚假唤醒了，但是队列还是没有空余容量 ，
那么当前线程还是会调用 wait()方法把自己挂起。

```java
//生产线程
synchronized (queue){
	//消费队列满，则等待队列空闲
		while(queue.size()==MAX_SIZE){
			try{
						//挂起当前线程，并释放通过同步块获取的queue上的锁，让消费者线程可以获取该锁，然后获取队列里面的元素			
						queue.wait();
			}catch(Exception ex){
					ex.printStackTrace();
			}
			//空闲则生成元素，并且通知消费者线程
			queue.add(ele);
			queue.notifyAll();
		}
}

//消费者线程 
synchronized (queue){
  //消费队列为空
  	while(queue.size()==0){
      try{
        	//挂起当前线程，并释放通过同步块获取的queue上的锁，让生产者线程可以获取该锁，将生产元素放入队列
        queue.wait();
      }catch(Exception ex){
        ex.printStackTrace();
      }
      //消费元素，并通知唤醒生产者线程
      queue.take();
      queue.notifyAll();
    }
}
```

上述代码中假如生产者线程A首先通过syncronized获取到了queue上面的锁，那么后续所有企图生产元素的线程和消费线程将会在获取该监视器锁的地方被阻塞挂起。线程A 获 取锁后发 现当前队列己 满会调用 queue.wait() 方法阻塞自己，然后释放获取的 queue上的锁，这里考虑下为何要释放该锁?如果不释放，由于其他生产者线程和所有消费者线程都己经被阻塞挂起，而线程 A 也被挂起，这就处于了死锁状态。这里线程A挂起自己后释放共享变量上的锁，就是为了打破死锁必要条件之一的持有并等待原则。关于死锁后面的章节会讲。线程 A释放锁后，其他生产者线程和所有消费者线程中会有一个线程获取 queue 上 的锁进而进入同步块，这就打破了死锁状态 。

需要注意的是，当前线程调用了共享变量的wait()方法后只会释放当前共享变量上的锁，如果当前线程还持有其他共享变量的锁，则这些锁是不会被释放的。如下代码：

``` java
//创建资源
private static volatile Object resourceA=new Object();
private static volatile Object resourceB=new Object();

public static void main(String[]args){
  //创建线程
  	Thread threadA=new Thread(new Runnable(){
      public void run(){
        try{
          	//获取resourceA共享资源
          		synchronized(resourceA){
                System.out.println("threadA get resourceA lock");
                	synchronized(resourceB){
                    System.out.println("thread get resourceB lock");
                    
                    //线程A阻塞，并释放获取到的resourceA的锁
                    System.out.println("thread release resourceA lock");
                    resourceA.wait();
                  }
              }
        }catch(InterruptedException e){
          	e.printStackTrace();
        }
      }
  
  
  	//创建线程
Thread threadB =new Thread(new Runnable() { publiC void run (){
		try {
			//休眠ls
					Thread . sleep(1000) ;
					//获取resourceA共享资源的监视器锁 
      	synchronized (resourceA ) {
					System .out .println (” threadB get resourceA lock...”);
                                System.out.println(”threadB try get 											
												//获取 resourceB共 享资源的监视器锁 
                synchronized (resourceB) {
								System.out.println (”threadB get resourceB lock”);
								//线斗呈B阻塞，并释放获取到的 resourceA的锁
								System.out .println (” threadB release resourceA lock" );
                             resourceA . wait () ;
                }
       }catch (InterruptedException e){
         
       }
	}
});
                  
                //启动线程
            threadA.start();
            threadB.start();
              	//等待两个线程结束
            threadA.join();
            threadB.join();
           
              System.out.println("main over")
    }
```

还有一个例子，当一个线程调用共享对象的wait()方法后被阻塞挂起后，如果其他线程中断了该线程，则该线程会抛出InterruptedException异常并且返回

``` java
public class WaitNotifyInterupt{
    static Object obj=new Object();
    public static void main(String[]args) throws InterruptedException{
        //创建线程
        Thread threadA = new Thread(new Runnable(){
            public void run(){
                try{
                    System.out.println("begin---");
                    //阻塞当前进程
                    synchronized(obj){
                        obj.wait();
                    }
                    System.out.println("end----");
                }catch(InterruptedException e){
                    e.printStackTrace();
                }
            }
        });
        threadA.start();
        Thread.sleep(1000);

        System.out.println("---begin interrupt threadA---");
        threadA.interrupt();
        System.out.println("--end interrupt threadA---");
    }

}
```

<h2 id="3">notify() 和notifyAll() </h2>

一个线程调用了共享对象的notify()方法后，会唤醒一个在该共享变量上调用wait()系列方法后被挂起的线程。一个共享变量上可能会有多个线程在等待，具体唤醒哪一个线程是随机的。notifyAll()方法是唤醒所有在该共享变量上由于调用wait()系列方法而被挂起的线程。



<h2 id="4">等待线程终止的join方法</h2>





